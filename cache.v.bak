module cache(CLK,WE,Address,Data_In,Data_Out);
    parameter NUMB = 256;
    parameter SIZE = 32;
    
    input CLK;
    input WE;
    input [SIZE:1]Data_In;		//写入的数据
    input [SIZE:1]Address;		//地址
    output [SIZE:1]Data_Out;	//读出数据
    
    reg [SIZE:1] Mem[256:0];	//存储器
    
    integer i;
    initial
		{Mem[0],Mem[1],Mem[2],Mem[3]}      <=  32'b000000_00001_00010_00011_00000_100000;     //add   $3,$1,$2    3号寄存器值为 3 
		{Mem[4],Mem[5],Mem[6],Mem[7]}      <=  32'b000000_00001_00010_00100_00000_100010;     //sub   $4,$1,$2    4号寄存器值为 -1
		{Mem[8],Mem[9],Mem[10],Mem[11]}    <=  32'b100011_00001_00101_00000_00000_000111;     //lw    $5,$1,7     5号寄存器值为 存储器 8
		{Mem[12],Mem[13],Mem[14],Mem[15]}  <=  32'b000000_00101_00001_00110_00000_100011;     //subu  $6,$5,$1    6号寄存器值为 8-1=7
		{Mem[16],Mem[17],Mem[18],Mem[19]}  <=  32'b000100_00001_00001_00000_00000_000010;     //beq   $1,$1,2      PC+1+2=4+1+2=7, 下一条是PC=7     4
		{Mem[20],Mem[21],Mem[22],Mem[23]}  <=  32'b000000_00001_00010_00101_00000_101011;
		{Mem[24],Mem[25],Mem[26],Mem[27]}  <=  32'b101011_00001_00011_00000_00000_000101;
		{Mem[28],Mem[29],Mem[30],Mem[31]}  <=  32'b000000_00100_00001_00111_00000_101010;      //slt   $7,$4,$1    有符合小于置1    7号寄存器值为 1
		{Mem[32],Mem[33],Mem[34],Mem[35]}  <=  32'b000000_00100_00001_01000_00000_101011;      //sltu  $8,$4,$1    无符合小于置1    8号寄存器值为 0
		{Mem[36],Mem[37],Mem[38],Mem[39]}  <=  32'b001001_00001_01001_11111_11111_111000;      //addiu $9, $1,立即数
		{Mem[40],Mem[41],Mem[42],Mem[43]}  <=  32'b101011_00001_01010_00000_00000_001111;      //sw    $10,$1,15   将10号寄存器的值存到 存储器 16中
		{Mem[44],Mem[45],Mem[46],Mem[47]}  <=  32'b001101_00111_01011_00000_00000_000010;      //ori   $11,$7,2   7号寄存器值为 1 与2  相或,结果为3 送11号寄存器
		{Mem[48],Mem[49],Mem[50],Mem[51]}  <=  32'b000010_00000_00000_00000_00000_000010;      //jump  跳转指令，   跳转到14
        //for(i=0;i<NUMB;i=i+1) Mem[i]<=i;
    always@(negedge CLK)
    begin
        if(WE)//写入
                Mem[Address]<=Data_In;
    end
    
    assign Data_Out=Mem[Address];
endmodule